"use strict";

var expression = require('expression');

module.exports = function(driver, bound, where, limit, offset) {
    var qui = driver.quoteUnqualifiedIdentifier;
    var boundParam = expression('?');

    var getTableFqName = function(table) {
        return table.schema !== undefined ?
            (qui(table.schema) + '.' + qui(table.table)) : qui(table.table);
    };

    var getSelectDelete = function(renderParams) {
        if (getSelectDelete.sql !== undefined) return getSelectDelete.sql;
        var tableSql = [];
        bound.aliasedTables().forEach(function(alias, table) {
            alias = qui(alias);

            var singleTableSql = getTableFqName(table);
            if (alias !== qui(table.table)) singleTableSql += ' AS ' + alias;
            if (table.condition !== undefined) {
                singleTableSql += ' ON ' + table.condition.render(driver, renderParams);
                tableSql.push(singleTableSql);
            } else {
                tableSql.unshift(singleTableSql);
            }
        });
        var selectDelete = ' FROM ' + tableSql.join(' JOIN ');
        if (where !== undefined) selectDelete += ' WHERE ' + where.render(driver, renderParams);
        if (limit !== undefined) selectDelete += ' LIMIT ' + limit;
        if (offset !== undefined) selectDelete += ' OFFSET ' + offset;

        // force ordering by pkey of master table for now. There is some
        // potential for custom ordering, but that's complicated.
        selectDelete += ' ORDER BY ' + Object.keys(bound.aliasedPkey()).map(qui).join(',');
        return getSelectDelete.sql = selectDelete;
    };

    var getSelect = function() {
        if (getSelect.sql !== undefined) return getSelect.sql;
        var renderParams = {};
        var columnSql = [];
        bound.aliasedColumns().forEach(function(alias, column) {
            columnSql.push(qui(column.table) + '.' + qui(column.name) + ' AS ' + qui(alias));
        });
        bound.selectExpressions().forEach(function(alias, expression) {
            columnSql.push(expression.render(driver, renderParams) + ' AS ' + qui(alias));
        });
        return getSelect.sql = 'SELECT ' + columnSql.join(',') + getSelectDelete(renderParams);
    };

    var getDelete = function() {
        if (getDelete.sql !== undefined) return getDelete.sql;
        var renderParams = {};
        var tableSql = [];
        bound.aliasedTables().forEach(function(alias) {
          tableSql.push(qui(alias));
        });
        return getDelete.sql = 'DELETE ' + tableSql.join(',') + getSelectDelete(renderParams);
    };

    var getInsert = function(table, row) {
        var sql = 'INSERT INTO ' + getTableFqName(table);
        var renderParams = {};
        var keys = Object.keys(row);
        if (keys.length === 0) {
            return sql + ' ' + driver.getDefaultValues();
        } else {
            sql += ' (' + keys.map(qui).join(',') + ') VALUES '
            return sql + '(' + keys.map(function() {
                return boundParam.render(driver, renderParams);
            }).join(',') + ')';
        }
    };

    var getUpdate = function(table, row, keyCols) {
      var keys = Object.keys(row);
      var renderParams = {};
      if (keys.length === 0) return ''; // nothing to do
      return 'UPDATE ' + getTableFqName(table) + ' SET ' +
          keys.map(function(col) {
              return qui(col) + '=' + boundParam.render(driver, renderParams);
          }).join(',') + ' WHERE ' + keyCols.map(qui).map(function(col) {
            return col + '=' + boundParam.render(driver, renderParams);
          }).join(' AND ');
    };

    var getParams = function(row) {
        var params = [];
        Object.keys(row).forEach(function(key) {
            params.push(row[key]);
        });
        return params;
    };

    return {
        "update" : function(objs, itemCallback, endCallback) {
            if (!(objs instanceof Array)) objs = [objs];
            var numUpdates = objs.length;
            objs.forEach(function (obj) {
                bound.save(obj, function(table, row, pkey, callback) {
                    var params = getParams(row);
                    var keys = [];
                    var missingKey = false;
                    pkey.forEach(function(col, val) {
                        if (val === undefined) {
                            callback(row);
                            if (endCallback !== undefined) {
                                endCallback("missing key on update: " + col);
                            }
                            missingKey = true;
                            return false;
                        } else {
                            params.push(val);
                            keys.push(col);
                            return true;
                        }
                    });
                    if (!missingKey) {
                        driver.run(getUpdate(table, row, keys), params, function() {
                            callback(row);
                        }, undefined, endCallback);
                    }
                }, function() {
                    if (itemCallback !== undefined) itemCallback(obj);
                    if (--numUpdates === 0 && endCallback !== undefined) {
                        endCallback();
                    }
                });
            });
        },
        "insert" : function(objs, itemCallback, endCallback) {
            if (!(objs instanceof Array)) objs = [objs];
            var numInserts = objs.length;
            objs.forEach(function (obj) {
                bound.save(obj, function(table, row, pkeys, callback) {
                    driver.runInsert(getInsert(table, row), getParams(row),
                            Object.keys(pkeys), callback, undefined, endCallback);
                }, function() {
                    if (itemCallback !== undefined) itemCallback(obj);
                    if (--numInserts === 0 && endCallback !== undefined) {
                        endCallback();
                    }
                });
            });
        },
        "delete" : function(params, callback) {
            // this deletes from all tables
            driver.run(getDelete(), params, undefined, callback, callback);
        },
        "select" : function(params, itemCallback, endCallback) {
            var result = [];
            var track = {};
            driver.run(getSelect(), params, function(row) {
                bound.extract(row, result, track);
                // we assume rows are ordered by pkey of master table. So if the
                // base transformation creates a new object, we know the prev
                // one is finished. We can deliver it then.
                // Like that we get a "streaming" behaviour.
                if (result.length > 1) {
                    var output = result.shift();
                    bound.purgeLast(track);
                    if (itemCallback !== undefined) itemCallback(output);
                }
            }, function() {
                if (itemCallback !== undefined) itemCallback(result[0]);
                if (endCallback !== undefined) endCallback();
            }, endCallback);
        }
    }
}