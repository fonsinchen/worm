"use strict";

var expression = require('expression');

module.exports = function(driver, bound, where, limit, offset) {
    var qui = driver.quoteUnqualifiedIdentifier;

    var getSelectDelete = function(renderParams) {
        if (getSelectDelete.sql !== undefined) return getSelectDelete.sql;
        var tableSql = [];
        bound.aliasedTables().forEach(function(alias, table) {
            var name = qui(table.table);
            alias = qui(alias);

            var singleTableSql = (table.schema !== undefined ?
                    qui(table.schema) + '.' + name : name);
            if (alias !== name) singleTableSql += ' AS ' + alias;
            if (table.condition !== undefined) {
                singleTableSql += ' ON ' + table.condition.render(driver, renderParams);
                tableSql.push(singleTableSql);
            } else {
                tableSql.unshift(singleTableSql);
            }
        });
        var selectDelete = ' FROM ' + tableSql.join(' JOIN ');
        if (where !== undefined) selectDelete += ' WHERE ' + where.render(driver, renderParams);
        if (limit !== undefined) selectDelete += ' LIMIT ' + limit;
        if (offset !== undefined) selectDelete += ' OFFSET ' + offset;

        // force ordering by pkey of master table for now. There is some
        // potential for custom ordering, but that's complicated.
        selectDelete += ' ORDER BY ' + Object.keys(bound.aliasedPkey()).map(qui).join(',');
        return getSelectDelete.sql = selectDelete;
    };

    var getSelect = function() {
        if (getSelect.sql !== undefined) return getSelect.sql;
        var renderParams = {};
        var columnSql = [];
        bound.aliasedColumns().forEach(function(alias, column) {
            columnSql.push(qui(column.table) + '.' + qui(column.name) + ' AS ' + qui(alias));
        });
        bound.selectExpressions().forEach(function(alias, expression) {
            columnSql.push(expression.render(driver, renderParams) + ' AS ' + qui(alias));
        });
        return getSelect.sql = 'SELECT ' + columnSql.join(',') + getSelectDelete(renderParams);
    };

    var getDelete = function() {
        if (getDelete.sql !== undefined) return getDelete.sql;
        var renderParams = {};
        var tableSql = [];
        bound.aliasedTables().forEach(function(alias) {
          tableSql.push(qui(alias));
        });
        return getDelete.sql = 'DELETE ' + tableSql.join(',') + getSelectDelete(renderParams);
    };
    
    var getInsert = function(table, row) {
        var renderParams = {};
        var boundParam = expression('?');
        var sql = 'INSERT INTO ' +
            (table.schema === undefined ? qui(table.table) : (qui(table.schema) + '.' + qui(table.table)));
        var keys = Object.keys(row);
        sql += '(' + keys.map(qui).join(',') + ') VALUES '
        return sql + '(' + keys.map(function() {
            return boundParam.render(driver, renderParams);
        }).join(',') + ')';
    };
    
    var getParams = function(row) {
        var params = [];
        Object.keys(row).foreach(function(key) {
            params.push(row[key]);
        });
        return params;
    };
    
    return {
        "sync" : function(objs, callback) {}, // Update if present, insert otherwise
        "update" : function(objs, callback) {},
        "insert" : function(objs, itemCallback, endCallback) {
            if (objs instanceof Array) {
                var numInserts = objs.length;
                objs.forEach(function (obj) {
                    bound.insert(obj, function(table, row, returning, keys) {
                        driver.runInsert(getInsert(table, row), getParams(row), returning, keys);
                    }, function() {
                        itemCallback(obj);
                        if (--numInserts === 0) endCallback();
                    });
                });
            } else {
                bound.insert(objs, driver, function() {
                    itemCallback(objs);
                    endCallback();
                });
            }
        },
        "delete" : function(params, callback) {
            // this deletes from all tables
            driver.run(getDelete(), params, undefined, callback, callback);
        },
        "select" : function(params, itemCallback, endCallback) {
            var result = [];
            var track = {};
            driver.run(getSelect(), params, function(row) {
                bound.extract(row, result, track);
                // we assume rows are ordered by pkey of master table. So if the
                // base transformation creates a new object, we know the prev
                // one is finished. We can deliver it then.
                // Like that we get a "streaming" behaviour.
                if (result.length > 1) {
                    var output = result.shift();
                    bound.purgeLast(track);
                    itemCallback(output);
                }
            }, function() {
                itemCallback(result[0]);
                endCallback();
            }, endCallback);
        }
    }
}