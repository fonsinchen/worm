"use strict";

module.exports = function(driver, bound, where, limit, offset) {
    var qui = driver.quoteUnqualifiedIdentifier;
    
    var getSelectDelete = function() {
        if (getSelectDelete.sql !== undefined) return getSelectDelete.sql;
        var tableSql = [];
        bound.aliasedTables().forEach(function(alias, table) {
            var name = qui(table.table);
            alias = qui(alias);

            var singleTableSql = (table.schema !== undefined ?
                    qui(table.schema) + '.' + name : name);
            if (alias !== name) singleTableSql += ' AS ' + alias;
            if (table.condition !== undefined) {
                singleTableSql += ' ON ' + table.condition.render(driver);
                tableSql.push(singleTableSql);
            } else {
                tableSql.unshift(singleTableSql);
            }
        });
        var selectDelete = ' FROM ' + tableSql.join(' JOIN ');
        if (where !== undefined) selectDelete += ' WHERE ' + where.render(driver);
        if (limit !== undefined) selectDelete += ' LIMIT ' + limit;
        if (offset !== undefined) selectDelete += ' OFFSET ' + offset;
        
        // force ordering by pkey of master table for now. There is some
        // potential for custom ordering, but that's complicated.
        selectDelete += ' ORDER BY ' + Object.keys(bound.aliasedPkey()).map(qui).join(',');
        return getSelectDelete.sql = selectDelete;
    };
    
    var getSelect = function() {
        if (getSelect.sql !== undefined) return getSelect.sql;
        var columnSql = [];
        bound.aliasedColumns().forEach(function(alias, column) {
            columnSql.push(qui(column.table) + '.' + qui(column.name) + ' AS ' + qui(alias));
        });
        bound.selectExpressions().forEach(function(alias, expression) {
            columnSql.push(expression.render(driver) + ' AS ' + qui(alias));
        });
        return getSelect.sql = 'SELECT ' + columnSql.join(',') + getSelectDelete();
    };
    
    var getDelete = function() {
        if (getDelete.sql !== undefined) return getDelete.sql;
        return getDelete.sql = 'DELETE ' + bound.aliasedTables().keys().map(qui).join(',') + getSelectDelete();
    }
    
    return {
        "sync" : function(objs, callback) {}, // Update if present, insert otherwise
        "update" : function(objs, callback) {},
        "insert" : function(objs, callback) {},
        "delete" : function(params, callback) {
            // this deletes from all tables
            driver.run(getDelete(), params, callback);
        },
        "select" : function(params, itemCallback, endCallback) {
            var result = [];
            driver.run(getSelect(), params, function(row) {
                bound.extract(row, result);
                // we assume rows are ordered by pkey of master table. So if the
                // base transformation creates a new object, we know the prev
                // one is finished. We can deliver it then.
                // Like that we get a "streaming" behaviour.
                if (result.length > 1) {
                    itemCallback(result.shift());
                }
            }, function() {
                itemCallback(result[0]);
                endCallback(null);
            }, function(error) {
                endCallback(error);
            });
        }
    }
}