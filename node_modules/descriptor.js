"use strict";

var transformation = require('transformation');

module.exports = function(qTableName, structure, descriptor) {
    var parent = transformation(descriptor);

    var tableName = null;
    var schemaName = null;
    var schema = null;

    var schemaTable = qTableName.split('.');
    if (schemaTable.length === 1) {
        schema = structure[0];
        if (schema === undefined) {
            schema = structure;
        } else if (typeof schema === 'string') {
            schema = structure[schema];
        } // else assume it's literally given.
        tableName = schemaTable[0];
    } else if (schemaTable.length === 2) {
        schemaName = schemaTable[0];
        schema = structure[schemaName];
        tableName = schemaTable[1];
    }
    var table = schema[tableName];
    var pkey = [];
    var columnPrefix = (schemaName === null ? '' : schemaName + '.') + tableName + '.';
    table.columns.forEach(function(name, column) {
        if (column.pkey) {
            pkey.push(columnPrefix + name);
            if (descriptor[name] === undefined) {
                fields.push(columnPrefix + name);
            }
        }
    });
    
    descriptor.forEach(function(key, val) {
        if (val === 1) {
            fields.push(columnPrefix + key);
        } else {
            children[columnPrefix + key] = val;
        }
    });
    
    // TODO parse, create chid descriptors
    return {
        from : function(driver) {
            var qui = driver.quoteUnqualifiedIdentifier;
            var from = {};
            var primaryTableName = (schemaName !== null ? qui(schemaName) + '.' : '') + qui(tableName);
            from[primaryTableName] = {
                schema : schemaName,
                table : tableName,
                condition : 0, // 0 means primary table, no join
                aliased : false
            };
            parent.from(from, {
                structure : structure,
                schema : schemaName,
                table : tableName,
                driver : driver
            });
            var ret = primaryTableName;
            from.forEach(function(alias, table) {
                ret += ' JOIN ';
                if (table.consition === 0) return;
                if (table.schema) ret += (qui(table.schema) + '.');
                ret += qui(table.name);
                if (table.aliased) ret += ' AS ' + alias;
                ret += ' ON ' + table.condition
            });
            return ret;
        },
        select : function(driver) {
            var select = {};
            table.columns.forEach(function(name, column) {
                if (column.pkey) {
                    select[name] = {
                        schema : schemaName,
                        table : tableName,
                        column : name
                    }
                }
            });
            parent.select(select, {
                structure : structure,
                schema : schemaName,
                table : tableName,
                driver : driver
            });
            return select;
        },
        update : function(driver) {},
        insert : function(driver) {},
        "delete" : function(driver) {}, // semantic is unclear: only delete from master table or from all?
        extract : function(driver, callback) {
            var objs = {};
            return {
                row : function(row) {
                    var currentObj = objs;
                    for (var i = 0; i < pkey.length; ++i) {
                        var keyVal = row[pkey[i]];
                        if (currentObj[keyVal] === undefined) currentObj[keyVal] = {};
                        currentObj = currentObj[keyVal];
                    }
                    if (currentObj.keys().length === 0) {
                        descriptor.forEach(function(key, val) {
                            if (val === 1) currentObj[columnPrefix + key] = row[columnPrefix + key];
                        });
                    }
                    children.forEach(function(child) {
                        child.extract(driver, row, currentObj)
                    });
                },
                end : function() {
                    //callback(null, row);
                    // finish last record ...
                }
            }
        }
    };
};