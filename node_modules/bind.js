var getDefaultSchema = function(model) {
    if (model[0] !== undefined) {
        switch (typeof model[0]) {
            case 'string': 
                return model[model[0]];
            case 'object':
                return model[0];
        }
    } else {
        return model;
    }
};

var getBaseTable = function(tableDesc, model) {
    if (typeof tableDesc === 'string') {
        tableDesc = tableDesc.split('.');
        if (tableDesc.length === 2) {
            return model[tableDesc[0]][tableDesc[1]];
        } else {
            return getDefaultSchema(model)[tableDesc[0]];
        }
    } else {
        if (tableDesc.schema !== undefined) {
            return model[tableDesc.schema][tableDesc.table];
        } else {
            return getDefaultSchema(model)[tableDesc.table];
        }
    }
};

module.exports = function(descriptor, model, tableDesc) {
    var uniquifier = 0;

    var tableAliases = {};
    var columnAliases = {};
    var columns = {};
    var expressions = {
        insert : {},
        select : {}
    }
    
    // we cannot recycle tables. The conditions might contain SQL parameters.
    var getTable = function(schema, table, condition) {
        var alias = table;
        while (tableAliases[alias] !== undefined) {
            alias = table + uniquifier++;
        }
        var desc = {
            schema : schema,
            table : table,
            condition : condition,
            alias : alias
        }
        tableAliases[alias] = desc;
        return desc;
    }
    
    var join = function(parent, key, direction, condition) {
        var foreign = model[parent.schema][parent.table][direction][key];
        if (parent !== undefined && condition === undefined) {
            var child = getTable(foreign.schema, foreign.table);
            
            condition = [];
            foreign.columns.forEach(function(column, i) {
                if (condition.length > 0) condition.push('AND');
                condition.push({
                    table : parent.alias,
                    column : column
                }, '=', {
                    table : child.alias,
                    column : foreign.foreign_columns[i]
                });
            });
            child.condition = condition;
            return child;
        } else {
            return getTable(foreign.schema, foreign.table, condition);
        }
    }
    
    var baseTable = getBaseTable(tableDesc, model);
    var base = require('transformation').bind(descriptor,
            join(undefined, baseTable.schema, baseTable.table), {
        one : function(parent, key, condition) {
            return join(parent, key, 'fkeys', condition);
        },
        many : function(parent, key, condition) {
            return join(parent, key, 'lkeys', condition);
        },
        column : function(table, name) {
            var hash = '"' + table.alias + '"."' + name + '"';
            if (columns[hash] !== undefined) {
                return columns[hash];
            } else {
                var alias = name;
                while (columnAliases[alias] !== undefined) {
                    alias = name + uniquifier++;
                }
                var column = {
                    alias : alias,
                    name : name,
                    table : table.alias
                };
                columns[hash] = column;
                columnAliases[alias] = column;
                return column;
            }
        },
        selectExpression : function(name, expression) {
            var alias = name;
            while (columnAliases[alias] !== undefined) {
                alias = name + uniquifier++;
            }
            expressions.select[alias] = expression;
            columnAliases[alias] = false;
            return alias;
        },
        insertExpression : function(table, name, expression) {
            var column = this.column(table, name);
            expressions.insert[column.alias] = expression;
            return column;
        }
    });
    
    return {
        aliasedColumns : function() {
            return columnAliases;
        },
        aliasedTables : function() {
            return tableAliases;
        },
        extract : function(row, results, track) {
            return base.extract(row, results, track);
        }
    };
};