var expression = require('expression');

var getDefaultSchema = function(model) {
    switch (typeof model['']) {
        case 'string': 
            return model[''];
        default:
            return undefined;
    }
};

var getBaseTable = function(tableDesc, model) {
    if (typeof tableDesc === 'string') {
        tableDesc = tableDesc.split('.');
        if (tableDesc.length === 2) {
            return {
                schema : tableDesc[0],
                table : tableDesc[1]
            }
        } else {
            return {
                schema : getDefaultSchema(model),
                table : tableDesc[0]
            }
        }
    } else {
        if (tableDesc.schema !== undefined) {
            return tableDesc;
        } else {
            return {
                schema : getDefaultSchema(model),
                table : tableDesc.table
            }
        }
    }
};

var getSchema = function(name, model) {
    if (name !== undefined) {
        return model[name];
    } else if (model[''] !== undefined) {
        if (typeof(model[''] === 'string')) {
            return model[model['']];
        } else {
            return model[''];
        }
    } else {
        return model;
    }
}

module.exports = function(descriptor, model, tableDesc) {
    var uniquifier = 0;

    var tableAliases = {};
    var columnAliases = {};
    var columns = {};
    var expressions = {
        insert : {},
        select : {}
    }
    
    // we cannot recycle tables. The conditions might contain SQL parameters.
    var getTable = function(schema, table, condition) {
        var alias = table;
        while (tableAliases[alias] !== undefined) {
            alias = table + uniquifier++;
        }
        var desc = {
            schema : schema,
            table : table,
            condition : condition,
            alias : alias,
            model : getSchema(schema, model)[table]
        }
        tableAliases[alias] = desc;
        return desc;
    }
    
    var join = function(parent, key, direction, condition) {
        var foreign = parent.model[direction][key];
        if (condition === undefined) {
            var child = getTable(foreign.schema, foreign.table);
            if (direction === 'lkeys') {
                foreign = getSchema(foreign.schema, model)[foreign.table]['fkeys'][foreign.name];
            }
            
            condition = [];
            var foreignAlias = (direction === 'lkeys' ? parent.alias : child.alias);
            var localAlias = (direction === 'lkeys' ? child.alias : parent.alias);
            foreign.local.forEach(function(column, i) {
                if (condition.length > 0) condition.push('AND');
                condition.push({
                    table : localAlias,
                    column : column
                }, '=', {
                    table : foreignAlias,
                    column : foreign.foreign[i]
                });
            });
            child.condition = expression.inject(condition);
            return child;
        } else {
            return getTable(foreign.schema, foreign.table, expression(condition));
        }
    }
    
    var baseTable = getBaseTable(tableDesc, model);
    var base = require('transformation').bind(descriptor,
            getTable(baseTable.schema, baseTable.table), {
        one : function(parent, key, condition) {
            return join(parent, key, 'fkeys', condition);
        },
        many : function(parent, key, condition) {
            return join(parent, key, 'lkeys', condition);
        },
        column : function(table, name) {
            var hash = '"' + table.alias + '"."' + name + '"';
            if (columns[hash] !== undefined) {
                return columns[hash];
            } else {
                var alias = name;
                while (columnAliases[alias] !== undefined ||
                        expressions.select[alias] !== undefined) {
                    alias = name + uniquifier++;
                }
                var column = {
                    alias : alias,
                    name : name,
                    table : table.alias
                };
                columns[hash] = column;
                columnAliases[alias] = column;
                return column;
            }
        },
        selectExpression : function(name, expr) {
            var alias = name;
            while (columnAliases[alias] !== undefined ||
                    expressions.select[alias] !== undefined) {
                alias = name + uniquifier++;
            }
            expressions.select[alias] = expression(expr);
            return alias;
        },
        insertExpression : function(table, name, expr) {
            var column = this.column(table, name);
            expressions.insert[column.alias] = expression(expr);
            return column;
        }
    });
    
    return {
        aliasedColumns : function() {
            return columnAliases;
        },
        aliasedTables : function() {
            return tableAliases;
        },
        extract : function(row, results, track) {
            return base.extract(row, results, track);
        },
        insert : function(obj, exec, end) {
            return base.insert(obj, exec, undefined, end);
        },
        purgeLast : base.purgeLast,
        aliasedPkey : function() {
            return base.pkey();
        },
        selectExpressions : function() {
            return expressions.select;
        },
        insertExpressions : function() {
            return expressions.insert;
        }
    };
};