"use strict";

var transformation = require('transformation');

var base = function(descriptor, structure, tableDesc, shared) {
    var schema = null, table = null;        

    var children = {};
    shared.schemaName = function() {
        return tableDesc.schema;
    };
    shared.tableName = function() {
        return tableDesc.table;
    };
    shared.schema = function() {
        return schema;
    };
    shared.table = function() {
        return table;
    };

    var getDefaultSchema = function() {
        if (structure[0] !== undefined) {
            switch (typeof structure[0]) {
                case 'string': 
                    tableDesc.schema = structure[0];
                    schema = structure[tableDesc.schema];
                    break;
                case 'object':
                    schema = structure[0];
                    break;
            }
        } else {
            schema = structure;
        }
    };

    var resolveSchema  = function() {
        if (typeof tableDesc === 'string') {
            tableDesc = tableDesc.split('.');
            if (tableDesc.length === 2) {
                tableDesc = {
                    table : tableDesc[1],
                    schema : tableDesc[0]
                }
                schema = structure[tableDesc.schema];
            } else {
                tableDesc = {
                    table : tableDesc[0]
                };
                getDefaultSchema();
            }
        } else {
            if (tableDesc.schema !== undefined) {
                schema = structure[tableDesc.schema];
            } else {
                getDefaultSchema();
            }
        }
        table = schema[tableDesc.table];
    };

    var resolveChildren = function() {
        descriptor.forEach(function(key, child) {
            switch(typeof child) {
                case 'string':
                    children[key] = transformation.expr(child).bind(structure, key, info);
                    break;
                case 'number':
                    children[key] = transformation.verbatim(child).bind(structure, key, info);
                    break;
                case 'object':
                    if (typeof child.retrieve === 'function' || typeof child.insert === 'function') {
                        children[key] = child.bind(structure, key, info);
                    } else if (table.fkeys !== undefined && table.fkeys[key] !== undefined) {
                        children[key] = transformation.one(child).bind(structure, key, info);
                    } else if (table.lkeys !== undefined && table.lkeys[key] !== undefined) {
                        children[key] = transformation.many(child).bind(structure, key, info);
                    } // else ignore or error?
                    break;
            }
        });
    };
    resolveSchema();
    resolveChildren();
    return children;
};

exports = function(descriptor, structure, tableDesc) {
    var shared = {};
    var tables = {};
    var columns = {};
    var children = base(descriptor, structure, tableDesc, shared);
    shared.tableAlias = shared.tableName;
    var tableName = shared.tableName();
    var resolveTables = function() {
        tables[tableName] = {table : tableName};
        if (shared.schemaName() !== null) tables[tableName].schema = shared.schemaName();
        children.forEach(function(key, child) {
            if (child.tables !== undefined) child.tables(tables, shared);
        });
    };

    var resolveColumns = function() {
        shared.table().columns.forEach(function(name, column) {
            if (column.pkey) columns[name] = [tableName, name];
        });
        children.forEach(function(key, child) {
            if (child.columns !== undefined) child.columns(columns, shared);
        });
    };

    resolveTables();
    resolveColumns();
    
    return {
        columns : function() {
            return columns;
        },
        tables : function() {
            return tables;
        }
    };
};

var uniquifier = 0;

exports.sub = function(descriptor, structure, tableDesc, keyName) {
    var shared = {};
    var children = base(descriptor, structure, tableDesc, shared);
    var tableName = shared.tableName();
    var pkeyAliases = {};
    
    return {
        columns : function(columns, info) {
            shared.table().columns.forEach(function(name, column) {
                if (column.pkey) {
                    var alias = name;
                    while (columns[name] !== undefined) alias += uniquifier++;
                    pkeyAliases[name] = alias;
                    columns[alias] = [shared.tableAlias(), name];
                }
            });
            children.forEach(function(key, child) {
                if (child.columns !== undefined) child.columns(columns, shared);
            });
            return shared;
        },
        tables : function(tables, info) {
            var alias = tableName;
            shared.tableAlias = function() {return alias;}
            while (tables[alias] !== undefined) alias += uniquifier++;
            tables[alias] = tableDesc;
            children.forEach(function(key, child) {
                if (child.tables !== undefined) child.tables(tables, shared);
            });
            return shared;
        }
    };
};