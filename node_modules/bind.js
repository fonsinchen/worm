"use strict";

var transformation = require('transformation');

var extract = function(driver, pkey, children, callback) {
    var objs = {};
    return {
        row : function(row) {
            var currentObj = objs;
            for (var i = 0; i < pkey.length; ++i) {
                var keyVal = row[pkey[i]];
                if (currentObj[keyVal] === undefined) currentObj[keyVal] = {};
                currentObj = currentObj[keyVal];
            }
            children.forEach(function(child) {
                child.extract(driver, row, currentObj)
            });
            // TODO: some logic to determine "last row of object" where possible
            // then we can callback here already
        },
        end : function() {
            //callback(null, row);
            // finish last record ...
        }
    }
}

// HOW THIS WORKS:
// first we resolve table names and aliases with aliasedTables(). We keep the
// mapping around in the private "tables" property of the main binder. This is a
// closure, so we can use the same descriptor/transformation multiple times in
// pseudo-parallel.
// Then we resolve the column names and aliases with aliasedColumns() using the
// table aliases. We keep the column mappings around in "columns" next to
// "tables". Finally, when doing extract() the mappings tell us which columns
// belong to which properties of the result rows.
// TODO: generalize for insert and update modes.
    
var base = function(descriptor, model, tableDesc, shared) {
    var schema = null, table = null;        

    var children = {};
    shared.schemaName = function() {
        return tableDesc.schema;
    };
    shared.tableName = function() {
        return tableDesc.table;
    };
    shared.schema = function() {
        return schema;
    };
    shared.table = function() {
        return table;
    };

    var getDefaultSchema = function() {
        if (model[0] !== undefined) {
            switch (typeof model[0]) {
                case 'string': 
                    tableDesc.schema = model[0];
                    schema = model[tableDesc.schema];
                    break;
                case 'object':
                    schema = model[0];
                    break;
            }
        } else {
            schema = model;
        }
    };

    if (typeof tableDesc === 'string') {
        tableDesc = tableDesc.split('.');
        if (tableDesc.length === 2) {
            tableDesc = {
                table : tableDesc[1],
                schema : tableDesc[0]
            }
            schema = model[tableDesc.schema];
        } else {
            tableDesc = {
                table : tableDesc[0]
            };
            getDefaultSchema();
        }
    } else {
        if (tableDesc.schema !== undefined) {
            schema = model[tableDesc.schema];
        } else {
            getDefaultSchema();
        }
    }
    table = schema[tableDesc.table];

    descriptor.forEach(function(key, child) {
        children[key] = child.bind(model, key, shared);
    });

    return children;
};

exports = function(descriptor, model, tableDesc) {
    var shared = {};
    var tables = {};
    var columns = {};
    var children = base(descriptor, model, tableDesc, shared);
    shared.tableAlias = shared.tableName;
    var tableName = shared.tableName();
    var resolveTables = function() {
        tables[tableName] = {table : tableName};
        if (shared.schemaName() !== null) tables[tableName].schema = shared.schemaName();
        children.forEach(function(key, child) {
            if (child.aliasedTables !== undefined) child.aliasedTables(tables, shared);
        });
    };

    var resolveColumns = function() {
        shared.table().columns.forEach(function(name, column) {
            if (column.pkey) columns[name] = [tableName, name];
        });
        children.forEach(function(key, child) {
            if (child.aliasedColumns !== undefined) child.aliasedColumns(columns, shared);
        });
    };

    resolveTables();
    resolveColumns();
    
    return {
        aliasedColumns : function() {
            return columns;
        },
        aliasedTables : function() {
            return tables;
        }
    };
};

var uniquifier = 0;

exports.sub = function(descriptor, model, tableDesc, keyName) {
    var shared = {};
    var children = base(descriptor, model, tableDesc, shared);
    var tableName = shared.tableName();
    var pkeyAliases = {};
    
    return {
        aliasedColumns : function(columns, info) {
            // Qualified column names are not enough. The database will return 
            // unqualified column names. The best bet is to keep all column 
            // names in a mapping and alias them as their qualified names with
            // SQL 'AS' when necessary:
            shared.table().columns.forEach(function(name, column) {
                if (column.pkey) {
                    var alias = name;
                    while (columns[name] !== undefined) alias += uniquifier++;
                    pkeyAliases[name] = alias;
                    columns[alias] = [shared.tableAlias(), name];
                }
            });
            children.forEach(function(key, child) {
                if (child.aliasedColumns !== undefined) child.aliasedColumns(columns, shared);
            });
            return shared;
        },
        aliasedTables : function(tables, info) {
            var alias = tableName;
            shared.tableAlias = function() {return alias;}
            while (tables[alias] !== undefined) alias += uniquifier++;
            tables[alias] = tableDesc;
            children.forEach(function(key, child) {
                if (child.aliasedTables !== undefined) child.aliasedTables(tables, shared);
            });
            return shared;
        }
    };
};