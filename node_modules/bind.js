"use strict";

var transformation = require('transformation');

var extract = function(driver, pkey, children, callback) {
    var objs = {};
    return {
        row : function(row) {
            var currentObj = objs;
            for (var i = 0; i < pkey.length; ++i) {
                var keyVal = row[pkey[i]];
                if (currentObj[keyVal] === undefined) currentObj[keyVal] = {};
                currentObj = currentObj[keyVal];
            }
            children.forEach(function(child) {
                child.extract(driver, row, currentObj)
            });
        },
        end : function() {
            //callback(null, row);
            // finish last record ...
        }
    }
}

var base = function(descriptor, structure, tableDesc, shared) {
    var schema = null, table = null;        

    var children = {};
    shared.schemaName = function() {
        return tableDesc.schema;
    };
    shared.tableName = function() {
        return tableDesc.table;
    };
    shared.schema = function() {
        return schema;
    };
    shared.table = function() {
        return table;
    };

    var getDefaultSchema = function() {
        if (structure[0] !== undefined) {
            switch (typeof structure[0]) {
                case 'string': 
                    tableDesc.schema = structure[0];
                    schema = structure[tableDesc.schema];
                    break;
                case 'object':
                    schema = structure[0];
                    break;
            }
        } else {
            schema = structure;
        }
    };

    if (typeof tableDesc === 'string') {
        tableDesc = tableDesc.split('.');
        if (tableDesc.length === 2) {
            tableDesc = {
                table : tableDesc[1],
                schema : tableDesc[0]
            }
            schema = structure[tableDesc.schema];
        } else {
            tableDesc = {
                table : tableDesc[0]
            };
            getDefaultSchema();
        }
    } else {
        if (tableDesc.schema !== undefined) {
            schema = structure[tableDesc.schema];
        } else {
            getDefaultSchema();
        }
    }
    table = schema[tableDesc.table];

    descriptor.forEach(function(key, child) {
        children[key] = child.bind(structure, key, shared);
    });

    return children;
};

exports = function(descriptor, structure, tableDesc) {
    var shared = {};
    var tables = {};
    var columns = {};
    var children = base(descriptor, structure, tableDesc, shared);
    shared.tableAlias = shared.tableName;
    var tableName = shared.tableName();
    var resolveTables = function() {
        tables[tableName] = {table : tableName};
        if (shared.schemaName() !== null) tables[tableName].schema = shared.schemaName();
        children.forEach(function(key, child) {
            if (child.joinTables !== undefined) child.joinTables(tables, shared);
        });
    };

    var resolveColumns = function() {
        shared.table().columns.forEach(function(name, column) {
            if (column.pkey) columns[name] = [tableName, name];
        });
        children.forEach(function(key, child) {
            if (child.aliasedColumns !== undefined) child.aliasedColumns(columns, shared);
        });
    };

    resolveTables();
    resolveColumns();
    
    return {
        aliasedColumns : function() {
            return columns;
        },
        joinTables : function() {
            return tables;
        }
    };
};

var uniquifier = 0;

exports.sub = function(descriptor, structure, tableDesc, keyName) {
    var shared = {};
    var children = base(descriptor, structure, tableDesc, shared);
    var tableName = shared.tableName();
    var pkeyAliases = {};
    
    return {
        aliasedColumns : function(columns, info) {
            shared.table().columns.forEach(function(name, column) {
                if (column.pkey) {
                    var alias = name;
                    while (columns[name] !== undefined) alias += uniquifier++;
                    pkeyAliases[name] = alias;
                    columns[alias] = [shared.tableAlias(), name];
                }
            });
            children.forEach(function(key, child) {
                if (child.aliasedColumns !== undefined) child.aliasedColumns(columns, shared);
            });
            return shared;
        },
        joinTables : function(tables, info) {
            var alias = tableName;
            shared.tableAlias = function() {return alias;}
            while (tables[alias] !== undefined) alias += uniquifier++;
            tables[alias] = tableDesc;
            children.forEach(function(key, child) {
                if (child.joinTables !== undefined) child.joinTables(tables, shared);
            });
            return shared;
        }
    };
};