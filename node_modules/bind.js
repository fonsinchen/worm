"use strict";

var transformation = require('transformation');

var extract = function(row, children, pkey, objs, callback) {
    var currentObj = objs;
    for (var i = 0; i < pkey.length; ++i) {
        var keyVal = row[pkey[i]];
        if (currentObj[keyVal] === undefined) currentObj[keyVal] = {};
        currentObj = currentObj[keyVal];
    }
    children.forEach(function(child) {
        child.extract(row, currentObj)
    });
    // TODO: some logic to determine "last row of object" where possible
    // then we can callback here already
}

// HOW THIS WORKS:
// first we resolve table names and aliases with aliasedTables(). We keep the
// mapping around in the private "tables" property of the main binder. This is a
// closure, so we can use the same descriptor/transformation multiple times in
// pseudo-parallel.
// Then we resolve the column names and aliases with aliasedColumns() using the
// table aliases. We keep the column mappings around in "columns" next to
// "tables". Finally, when doing extract() the mappings tell us which columns
// belong to which properties of the result rows.
// TODO: generalize for insert and update modes.
    
var base = function(descriptor, model, tableDesc, shared) {
    var schema = null, table = null;        

    var children = {};
    shared.schemaName = function() {
        return tableDesc.schema;
    };
    shared.tableName = function() {
        return tableDesc.table;
    };
    shared.schema = function() {
        return schema;
    };
    shared.table = function() {
        return table;
    };
    shared.extract = function(row, results) {
        shared.pkeys().forEach(function(key) {
            var keyVal = row[key];
            if (results[keyVal] === undefined) results[keyVal] = {};
            results = results[keyVal];
        });
        children.forEach(function(child) {
            child.extract(row, results)
        });
    };

    var getDefaultSchema = function() {
        if (model[0] !== undefined) {
            switch (typeof model[0]) {
                case 'string': 
                    tableDesc.schema = model[0];
                    schema = model[tableDesc.schema];
                    break;
                case 'object':
                    schema = model[0];
                    break;
            }
        } else {
            schema = model;
        }
    };

    if (typeof tableDesc === 'string') {
        tableDesc = tableDesc.split('.');
        if (tableDesc.length === 2) {
            tableDesc = {
                table : tableDesc[1],
                schema : tableDesc[0]
            }
            schema = model[tableDesc.schema];
        } else {
            tableDesc = {
                table : tableDesc[0]
            };
            getDefaultSchema();
        }
    } else {
        if (tableDesc.schema !== undefined) {
            schema = model[tableDesc.schema];
        } else {
            getDefaultSchema();
        }
    }
    table = schema[tableDesc.table];

    descriptor.forEach(function(key, child) {
        children[key] = child.bind(model, key, shared);
    });

    return children;
};

exports = function(descriptor, model, tableDesc) {
    var shared = {};
    var tables = {};
    var columns = {};
    var pkeys = [];
    var children = base(descriptor, model, tableDesc, shared);
    shared.tableAlias = shared.tableName;
    shared.pkeys = function() {return pkeys;};
    var tableName = shared.tableName();
    
    var selectResults = {};

    tables[tableName] = {table : tableName};
    if (shared.schemaName() !== null) tables[tableName].schema = shared.schemaName();
    children.forEach(function(key, child) {
        if (child.aliasedTables !== undefined) child.aliasedTables(tables, shared);
    });

    shared.table().columns.forEach(function(name, column) {
        if (column.pkey) {
            columns[name] = [tableName, name];
            pkeys.push(name);
        }
    });
    children.forEach(function(key, child) {
        if (child.aliasedColumns !== undefined) child.aliasedColumns(columns, shared);
    });
    
    return {
        aliasedColumns : function() {
            return columns;
        },
        aliasedTables : function() {
            return tables;
        },
        extract : function(row) {
            shared.extract(row, selectResults);
        }
    };
};

var uniquifier = 0;

exports.sub = function(descriptor, model, tableDesc, keyName) {
    var shared = {};
    var children = base(descriptor, model, tableDesc, shared);
    var tableName = shared.tableName();
    var pkeys = [];
    shared.pkeys = function() {return pkeys;};
    
    return {
        aliasedColumns : function(columns, info) {
            // Qualified column names are not enough. The database will return 
            // unqualified column names. The best bet is to keep all column 
            // names in a mapping and alias them as their qualified names with
            // SQL 'AS' when necessary:
            shared.table().columns.forEach(function(name, column) {
                if (column.pkey) {
                    var alias = name;
                    while (columns[name] !== undefined) alias += uniquifier++;
                    pkeys.push(alias);
                    columns[alias] = [shared.tableAlias(), name];
                }
            });
            children.forEach(function(key, child) {
                if (child.aliasedColumns !== undefined) child.aliasedColumns(columns, shared);
            });
            return shared;
        },
        aliasedTables : function(tables, info) {
            var alias = tableName;
            shared.tableAlias = function() {return alias;}
            while (tables[alias] !== undefined) alias += uniquifier++;
            tables[alias] = tableDesc;
            children.forEach(function(key, child) {
                if (child.aliasedTables !== undefined) child.aliasedTables(tables, shared);
            });
            return shared;
        },
        extract : function(row) {
            shared.extract(row, selectResults);
        }
    };
};