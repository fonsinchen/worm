exports.bind = function(descriptor, table, store) {
    var verbatim = [];       // columns to be just added to the result
    var transformation = []; // transformations without joins
    var join = [];           // transformations with joins
    var pkey = {};           // pkey columns of own table
    
    if (typeof descriptor === 'object') {
        descriptor.forEach(function(key, child) {
            if (child === 1) {
                verbatim.push(store.column(table, key));
            } else {
                var boundChild = child.bind(key, table, store);
                if (child.joins) {
                    join.push(boundChild);
                } else {
                    transformation.push(boundChild);
                }
            }
        });
    } else {
        // special syntax for single columns
        verbatim.push(store.column(table, descriptor)); 
    }

    table.model.columns.forEach(function(name, props) {
        if (props.pkey) {
            var column = store.column(table, name);
            pkey[column.alias] = column;;
        }
    });
    
    return {
        extract : function(row, results, track) {
            var isNew = false;
            if (track[table.alias] === undefined) track[table.alias] = {};
            var localResult = track[table.alias];
            pkey.forEach(function(alias) {
                var keyVal = row[alias];
                if (localResult[keyVal] === undefined) {
                    localResult[keyVal] = {};
                    isNew = true;
                }
                localResult = localResult[keyVal];
            });
            if (isNew) {
                localResult.val = {};
                localResult.track = {};
                results.push(localResult.val);
            }
            this.recurse(row, localResult.val, localResult.track, isNew);
        },
        
        recurse : function(row, result, track, isNew) {
            if (isNew) {
                transformation.forEach(function(child) {
                    child.extract(row, result)
                });
                verbatim.forEach(function(column) {
                    result[column.name] = row[column.alias];
                });
            }
            join.forEach(function(child) {
                child.extract(row, result, track, isNew)
            });
            
        },
        
        pkey : function() {
            return pkey;
        }
    }
};

exports.one = function(descriptor, condition) {
    return {
        bind : function(key, table, store, name) {
            if (name === undefined) name = key;
            var bound = exports.bind(descriptor, store.one(table, key, condition), store);
            return {
                extract : function(row, result, track, isNew) {
                    if (isNew) result[name] = {};
                    bound.recurse(row, result[name], track, isNew);
                }
            }
        },
        joins : true
    }
};

exports.flatten = function(descriptor, condition) {
    return {
        bind : function(key, table, store) {
            var bound = exports.bind(descriptor, store.one(table, key, condition), store);
            return {
                extract : bound.recurse
            }
        },
        joins : true
    }
};

exports.many = function(descriptor, condition) {
    return {
        bind : function(key, table, store, name) {
            if (name === undefined) name = key;
            var bound = exports.bind(descriptor, store.many(table, key, condition), store);
            return {
                extract : function(row, result, track) {
                    if (result[name] === undefined) result[name] = [];
                    bound.extract(row, result[name], track);
                }
            }
        },
        joins : true
    }
};

exports.enumerate = function(column, condition) {
    return {
        bind : function(key, table, store, name) {
            if (name === undefined) name = key;
            var bound = exports.bind(column, store.many(table, key, condition), store);
            return {
                extract : function(row, result, track) {
                    var field = [];
                    bound.extract(row, field, track);
                    if (field.length === 1) {
                        if (result[name] === undefined) {
                            result[name] = [field[0][column]];
                        } else {
                            result[name].push(field[0][column]);
                        }
                    }
                }
            }
        },
        joins : true
    }
}

exports.rename = function(columnName, descriptor) {
    return {
        bind : function(key, table, store, name) {
            if (name === undefined) name = key;
            var bound = null;
            var column = null;
            if (descriptor === undefined) {
                column = store.column(table, columnName);
            } else {
                bound = descriptor.bind(columnName, table, store, name);
            }
            return {
                extract : function(row, result, track, isNew) {
                    if (bound !== null) {
                        bound.extract(row, result, track, isNew);
                    } else if (typeof descriptor === 'string') {
                        result[name] = row[column.alias];
                    } // else?
                }
            }
        },
        joins : (descriptor !== undefined) && descriptor.joins
    }
};

exports.bloat = function(descriptor) {
    return {
        bind : function(key, table, store, name) {
            if (name === undefined) name = key;
            var bound = exports.bind(descriptor, table, store);
            return {
                extract : function(row, result, track) {
                    if (result[name] === undefined) result[name] = {};
                    bound.extract(row, result[name], track);
                }
            }
        }
    };
};

exports.transform = function(extract, insert) {
    return {
        bind : function(key, table, store, name) {
            if (name === undefined) name = key;
            var column = store.column(table, key);
            return {
                extract : function(row, result) {
                    result[name] = extract(row[column.alias]);
                }
            }
        }
    }
};

exports.expr = function(expr, insertExprs) {
    return {
        bind : function(key, table, store, name) {
            if (name === undefined) name = key;
            var alias = store.selectExpression(name, expr)
            if (insertExprs !== undefined) {
                insertExprs.forEach(function(key, insert) {
                    store.insertExpression(table, key, insert);
                });
            } else {
                insertExprs = {};
            }
            return {
                extract : function(row, result) {
                    result[name] = row[alias];
                }
            }
        }
    }
};