"use strict";

var sqlexpr = require('sqlexpr');

/**
 * prepare descriptor and create abbreviated subdescriptors:
 * - if val is a string, assume it's an SQL expression
 * - if val is an object, but doesn't have typical methods assume descriptor for either worm.one or worm.many
 *   * if key contains at least one dot, assume worm.many with qualified fkey name
 *   * if key doesn't contain a dot, assume worm.one with bare fkey name
 */   
exports.prepare = function(descriptor) {
    descriptor.forEach(function(key, child) {
        switch(typeof child) {
            case 'string':
                descriptor[key] = exports.expr(child);
                break;
            case 'number':
                descriptor[key] = exports.verbatim(child);
                break;
        }
    });
}

var uniquifier = 0;

exports.varbatim = function() {
    return {
        bind : function(model, key) {
            var columnAlias = key;
            var desc = null;
            
            return {
                aliasedTables : function(tables, info) {
                    desc = [info.tableAlias(), key];
                },
                aliasedColumns : function(columns) {
                    while(columns[columnAlias] !== undefined &&
                            (columns[columnAlias][0] !== desc[0] ||
                            columns[columnAlias][1] !== desc[1])) {
                        columnAlias += uniquifier++;
                    }
                    columns[columnAlias] = desc;
                },
                extract : function(row, results) {
                    results[columnAlias] = row[columnAlias];
                }
            }
        }
    }
};

exports.expr = function(expr, insertExprs) {
    var parseTree = sqlexpr.parse(expr);
    var parsedInserts = {};
    if (insertExprs !== undefined) {
        insertExprs.forEach(function(key, insert) {
            parsedInserts[key] = sqlexpr.parse(insert);
        });
    }
    return {
        bind : function(model, key) {
            var columnAlias = key;
            return {
                // TODO: here we have different columns depending on mode
                // for now we only consider SELECT
                aliasedColumns : function(columns) {
                    while(columns[columnAlias] !== undefined) {
                        columnAlias += uniquifier++;
                    }
                    columns[columnAlias] = parseTree;
                },
                extract : function(row, results) {
                    results[columnAlias] = row[columnAlias];
                }
            }
        }
    }
};

var join = function(descriptor, condition, bindKey) {
    exports.prepare(descriptor);
    return {
        bind : function(model, keyName, info) {
            var key = info.table()[bindKey][keyName];
            var tableDesc = {
                schema : key.schema,
                table : key.table,
                condition : condition
            };
            var child = require('bind').sub(descriptor, model, tableDesc, keyName);
            return {
                aliasedTables : function(tables, info) {
                    // TODO: maybe avoid multiple equivalent joins. Might not be
                    // worth the hassle, though.
                    var subInfo = child.tables(tables, info);
                    var fkey = (bindKey === 'lkey' ? subInfo.table().fkeys[key.name] : key);
                    if (tableDesc.condition === undefined) {
                        var condition = [];
                        fkey.columns.forEach(function(column, i) {
                            if (condition.length > 0) condition.push('AND');
                            condition.push({
                                table : info.tableAlias(),
                                column : column
                            }, '=', {
                                table : subInfo.tableAlias(),
                                colun : fkey.foreign_columns[i]
                            });
                        });
                    }
                },
                aliasedColumns : child.columns,
                extract : child.extract
            }
        }
    }
}

exports.many = function(descriptor, condition) {
    return join(descriptor, condition, 'lkey');
};

exports.one = function(descriptor, condition) {
    return join(descriptor, condition, 'fkey');
};