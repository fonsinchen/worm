"use strict";

exports = function(descriptor) {
    var fields = [];
    var children = {};
    
    // TODO: sane abbrevations
    // - if val is a string, assume it's an SQL expression
    // - if val is an object, but doesn't have typical methods assume descriptor for either worm.one or worm.many
    //   * if key contains at least one dot, assume worm.many with qualified fkey name
    //   * if key doesn't contain a dot, assume worm.one with bare fkey name
    descriptor.forEach(function(key, val) {
        if (val === 1) {
            fields.push(key);
        } else {
            children[key] = val;
        }
    });
    
    var cascade = function(result, method, params) {
        children.forEach(function(key, child) {
            child[method](result, {
                structure : params.structure,
                schema : params.schema,
                table : params.table,
                property : key,
                driver : params.driver
            });
        });
    }
    // TODO:
    // first resolve table names and aliases with from(). Keep the mapping
    // around somewhere. Use closures or instances in order to be able to use
    // the same descriptor/transformation multiple times in pseudo-parallel.
    // Then resolve the column names and aliases with select() using the table
    // aliases. Keep the column mappings around, too. Finally, when doing
    // extract() the mappings tell us which columns belong to which properties
    // of the result rows.
    return {
        from : function(result, params) {
            // alias : {schema : "schema", table : "table", condition : "z.fkey = table.key", aliased : false}
            // Create normalized conditions to be able to string-compare them
            // and avoid multiple equivalent joins.
            return cascade(result, 'from', params);
        },
        select : function(result, params) {
            // Qualified column names are not enough! The database may return 
            // unqualified column names. The best bet is probably to keep all
            // column names in a mapping and alias them as their qualified names
            // with SQL 'AS' when necessary:
            // {
            //  'x' : {schame : 'schema', table : 'table', column : 'x'},
            //  'table2.x' : {schema : 'schema', schema : 'table2', column : 'x'}, 
            //  'schema2.table2.x' : {alias : 'tableAlias', column : 'x'}
            // }
            // The mapping has to be around when extracting later.
            var qui = params.driver.quoteUnqualifiedIdentifier;
            var tablePrefix = (params.schema === null ? '' : qui(params.schema) + '.') +
                    qui(params.table) + '.';
            var select = fields.map(function(field) {
                return tablePrefix + qui(field);
            });
            return cascade(select, 'select', params);
        }
    }   
};