"use strict";

exports.bind = function(descriptor, table, store) {
    var verbatim = [];       // columns to be just added to the result
    var transformation = []; // transformations without joins
    var join = [];           // transformations with joins
    var pkey = {};           // pkey columns of own table
    
    if (typeof descriptor === 'object') {
        descriptor.forEach(function(key, child) {
            if (child === 1) {
                verbatim.push(store.column(table, key));
            } else {
                var boundChild = child.bind(key, table, store);
                if (child.joins) {
                    join.push(boundChild);
                } else {
                    transformation.push(boundChild);
                }
            }
        });
    } else {
        // special syntax for single columns
        verbatim.push(store.column(table, descriptor)); 
    }

    table.model.columns.forEach(function(name, props) {
        if (props.pkey) {
            var column = store.column(table, name);
            column["default"] = props["default"];
            pkey[column.alias] = column;
        }
    });
    
    return {
        extract : function(row, results, track) {
            var isNew = false;
            var tableTrack = track[table.alias];
            if (tableTrack === undefined) tableTrack = (track[table.alias] = {
                keys : {}
            });
            
            var localResult = tableTrack.keys;
            tableTrack.last = tableTrack.current;
            var current = (track[table.alias].current = []);
            pkey.forEach(function(alias) {
                var keyVal = row[alias];
                current.push(keyVal);
                if (localResult[keyVal] === undefined) {
                    localResult[keyVal] = {};
                    isNew = true;
                }
                localResult = localResult[keyVal];
            });
            if (isNew) {
                localResult.val = {};
                localResult.track = {};
                results.push(localResult.val);
            }
            this.recurse(row, localResult.val, localResult.track, isNew);
        },
        
        insert : function(obj, exec, keys) {
            var row = {};
            transformation.forEach(function(child) {
                child.insert(row, obj)
            });
            verbatim.forEach(function(column) {
                row[column.name] = obj[column.alias];
            });
            var oneJoins = 0;
            join.forEach(function(child) {
                if (child.joins === 'one') {
                    oneJoins++;
                    child.insert(obj, exec, function(childKey) {
                        childKey.forEach(function(key, val) {
                            row[key] = val;
                        });
                        if (--oneJoins === 0) {
                            exec(row, function(key) {
                                var rowKeys = {};
                                pkey.forEach(function(alias, column) {
                                    if (key[column.name] !== undefined) {
                                        // key has been autogenerated
                                        row[column.name] = rowKeys[column.name] = key[column.name];
                                    } else if (row[column.name] !== undefined) {
                                        // key was explicitly given
                                        rowKeys[column.name] = row[column.name];
                                    } else if (column["default"] !== undefined) {
                                        // key has default value
                                        row[column.name] = rowKeys[column.name] = column["default"];
                                    }
                                });
                                keys(rowKeys);
                            });
                        };
                    });
                }
            });
        },
        
        purgeLast : function(track) {
            function recurse(localResult, last, i) {
                if (i === last.length - 1) {
                    delete localResult[last[i]];
                } else {
                    recurse(localResult[last[i]], last, i + 1);
                    if (localResult.keys().length === 1) {
                        delete localResult[last[i]];
                    }
                }
            }
            var localResult = track[table.alias].keys;
            var last = track[table.alias].last;
            recurse(localResult, last, 0);
        },
        
        recurse : function(row, result, track, isNew) {
            if (isNew) {
                transformation.forEach(function(child) {
                    child.extract(row, result)
                });
                verbatim.forEach(function(column) {
                    result[column.name] = row[column.alias];
                });
            }
            join.forEach(function(child) {
                child.extract(row, result, track, isNew)
            });
            
        },
        
        pkey : function() {
            return pkey;
        }
    }
};

exports.one = function(descriptor, condition) {
    return {
        bind : function(key, table, store, name) {
            if (name === undefined) name = key;
            var bound = exports.bind(descriptor, store.one(table, key, condition), store);
            return {
                extract : function(row, result, track, isNew) {
                    if (isNew) result[name] = {};
                    bound.recurse(row, result[name], track, isNew);
                }
            }
        },
        joins : "one"
    }
};

exports.flatten = function(descriptor, condition) {
    return {
        bind : function(key, table, store) {
            var bound = exports.bind(descriptor, store.one(table, key, condition), store);
            return {
                extract : bound.recurse
            }
        },
        joins : "one"
    }
};

exports.many = function(descriptor, condition) {
    return {
        bind : function(key, table, store, name) {
            if (name === undefined) name = key;
            var bound = exports.bind(descriptor, store.many(table, key, condition), store);
            return {
                extract : function(row, result, track) {
                    if (result[name] === undefined) result[name] = [];
                    bound.extract(row, result[name], track);
                }
            }
        },
        joins : "many"
    }
};

exports.enumerate = function(column, condition) {
    return {
        bind : function(key, table, store, name) {
            if (name === undefined) name = key;
            var bound = exports.bind(column, store.many(table, key, condition), store);
            return {
                extract : function(row, result, track) {
                    var field = [];
                    bound.extract(row, field, track);
                    if (field.length === 1) {
                        if (result[name] === undefined) {
                            result[name] = [field[0][column]];
                        } else {
                            result[name].push(field[0][column]);
                        }
                    }
                }
            }
        },
        joins : "many"
    }
}

exports.rename = function(columnName, descriptor) {
    return {
        bind : function(key, table, store, name) {
            if (name === undefined) name = key;
            var bound = null;
            var column = null;
            if (descriptor === undefined) {
                column = store.column(table, columnName);
            } else {
                bound = descriptor.bind(columnName, table, store, name);
            }
            return {
                extract : function(row, result, track, isNew) {
                    if (bound !== null) {
                        bound.extract(row, result, track, isNew);
                    } else if (descriptor === undefined) {
                        result[name] = row[column.alias];
                    } // else?
                }
            }
        },
        joins : (descriptor !== undefined) && descriptor.joins
    }
};

exports.bloat = function(descriptor) {
    return {
        bind : function(key, table, store, name) {
            if (name === undefined) name = key;
            var bound = exports.bind(descriptor, table, store);
            return {
                extract : function(row, result, track) {
                    if (result[name] === undefined) result[name] = {};
                    if (descriptor.joins) {
                        bound.extract(row, result[name], track);
                    } else {
                        bound.recurse(row, result[name], track, true);
                    }
                }
            }
        },
        joins : descriptor.joins
    };
};

exports.transform = function(extract, insert) {
    return {
        bind : function(key, table, store, name) {
            if (name === undefined) name = key;
            var column = store.column(table, key);
            return {
                extract : function(row, result) {
                    result[name] = extract(row[column.alias]);
                }
            }
        }
    }
};

exports.expr = function(expr, insertExprs) {
    return {
        bind : function(key, table, store, name) {
            if (name === undefined) name = key;
            var alias = store.selectExpression(name, expr)
            if (insertExprs !== undefined) {
                insertExprs.forEach(function(key, insert) {
                    store.insertExpression(table, key, insert);
                });
            } else {
                insertExprs = {};
            }
            return {
                extract : function(row, result) {
                    result[name] = row[alias];
                }
            }
        }
    }
};