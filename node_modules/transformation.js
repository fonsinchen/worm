"use strict";

exports.bind = function(descriptor, table, store) {
    var verbatim = [];       // columns to be just added to the result
    var transformation = []; // transformations without joins
    var one = [];            // transformations with one-to-many joins
    var many = [];           // transformations with many-to-one joins
    var pkey = {};           // pkey columns of own table

    if (typeof descriptor === 'object') {
        descriptor.forEach(function(key, child) {
            if (child === 1) {
                verbatim.push(store.column(table, key));
            } else {
                var boundChild = child.bind(key, table, store);
                if (child.joins === 'one') {
                    one.push(boundChild);
                } else if (child.joins === 'many') {
                    many.push(boundChild);
                } else {
                    transformation.push(boundChild);
                }
            }
        });
    } else {
        // special syntax for single columns
        verbatim.push(store.column(table, descriptor));
    }

    table.model.columns.forEach(function(name, props) {
        if (props.pkey) {
            var column = store.column(table, name);
            column["default"] = props["default"];
            column.auto = props.auto;
            pkey[column.alias] = column;
        }
    });

    return {
        extract : function(row, results, track) {
            var isNew = false;
            var tableTrack = track[table.alias];
            if (tableTrack === undefined) tableTrack = (track[table.alias] = {
                keys : {}
            });

            var localResult = tableTrack.keys;
            tableTrack.last = tableTrack.current;
            var current = (track[table.alias].current = []);
            pkey.forEach(function(alias) {
                var keyVal = row[alias];
                current.push(keyVal);
                if (localResult[keyVal] === undefined) {
                    localResult[keyVal] = {};
                    isNew = true;
                }
                localResult = localResult[keyVal];
            });
            if (isNew) {
                localResult.val = {};
                localResult.track = {};
                results.push(localResult.val);
            }
            this.recurse(row, localResult.val, localResult.track, isNew);
        },

        collect : function(obj, row) {
            transformation.forEach(function(child) {
                child.insert(obj, row)
            });
            verbatim.forEach(function(column) {
                row[column.name] = obj[column.alias];
            });
        },

        insert : function(obj, exec, keys, end) {
            var row = {};
            this.collect(obj, row);
            var oneJoins = one.length;
            var allJoins = oneJoins + many.length;
            var keyColumns = [];
            pkey.forEach(function(alias, column) {
                keyColumns.push(column.name);
            });

            var doInsert = function() {
                // remove auto-generated columns
                pkey.forEach(function(alias, column) {
                    if (column.auto) delete row[column.name];
                });
                if (table.fkeys !== undefined && typeof keys === 'object') {
                    table.fkeys.forEach(function(local, foreign) {
                        if (keys.row[foreign] !== undefined) {
                            row[local] = keys.row[foreign];
                        } else if (keys.keys[foreign] !== undefined) {
                            row[local] = keys.keys[foreign];
                        }
                    });
                }
                exec(table, row, keyColumns, handleMany);
            };

            var handleMany = function(key) {
                var rowKeys = {};
                pkey.forEach(function(alias, column) {
                    if (key[column.name] !== undefined) {
                        // key has been autogenerated
                        rowKeys[column.name] = row[column.name] = key[column.name];
                    } else if (row[column.name] !== undefined) {
                        // key was explicitly given
                        rowKeys[column.name] = row[column.name];
                    } else if (column["default"] !== undefined) {
                        // key has default value
                        rowKeys[column.name] = row[column.name] = column["default"];
                    }
                });
                if (typeof keys === "function") keys(rowKeys, row);
                many.forEach(function(child) {
                    child.insert(obj, exec, {
                        keys : rowKeys,
                        row : row
                    }, function() {
                        if (--allJoins === 0 && end !== undefined) end();
                    });
                });
            };

            if (oneJoins === 0) {
                doInsert();
            } else {
                one.forEach(function(child) {
                    child.insert(obj, exec, function(childKey, childRow) {
                        child.fkeys().forEach(function(childCol, parentCol) {
                            if (childRow[childCol] !== undefined) {
                                row[parentCol] = childRow[childCol];
                            } else if (childKey[childCol] !== undefined) {
                                row[parentCol] = childKey[childCol];
                            } else {
                                // key is missing. What to do??
                            }
                        });
                        --allJoins;
                        if (--oneJoins === 0) doInsert()
                    }, function() {
                        if (--allJoins === 0 && end !== undefined) end();
                    });
                });
            }
        },

        fkeys : function() {
            return table.fkeys;
        },

        purgeLast : function(track) {
            function recurse(localResult, last, i) {
                if (i === last.length - 1) {
                    delete localResult[last[i]];
                } else {
                    recurse(localResult[last[i]], last, i + 1);
                    if (localResult.keys().length === 1) {
                        delete localResult[last[i]];
                    }
                }
            }
            var localResult = track[table.alias].keys;
            var last = track[table.alias].last;
            recurse(localResult, last, 0);
        },

        recurse : function(row, result, track, isNew) {
            if (isNew) {
                transformation.forEach(function(child) {
                    child.extract(row, result)
                });
                verbatim.forEach(function(column) {
                    result[column.name] = row[column.alias];
                });
            }
            one.forEach(function(child) {
                child.extract(row, result, track, isNew)
            });
            many.forEach(function(child) {
                child.extract(row, result, track, isNew)
            });

        },

        pkey : function() {
            return pkey;
        }
    }
};

exports.one = function(descriptor, condition) {
    return {
        bind : function(key, table, store, name) {
            if (name === undefined) name = key;
            var bound = exports.bind(descriptor, store.one(table, key, condition), store);
            return {
                extract : function(row, result, track, isNew) {
                    if (isNew) result[name] = {};
                    bound.recurse(row, result[name], track, isNew);
                },
                insert : function(obj, exec, keys, end) {
                    bound.insert(obj[name], exec, keys, end);
                },
                fkeys : bound.fkeys
            }
        },
        joins : "one"
    }
};

exports.flatten = function(descriptor, condition) {
    return {
        bind : function(key, table, store) {
            var bound = exports.bind(descriptor, store.one(table, key, condition), store);
            return {
                extract : bound.recurse,
                insert : function(obj, exec, keys, end) {
                    bound.insert(obj, exec, keys, end);
                },
                fkeys : bound.fkeys
            }
        },
        joins : "one"
    }
};

exports.many = function(descriptor, condition) {
    return {
        bind : function(key, table, store, name) {
            if (name === undefined) name = key;
            var bound = exports.bind(descriptor, store.many(table, key, condition), store);
            return {
                extract : function(row, result, track) {
                    if (result[name] === undefined) result[name] = [];
                    bound.extract(row, result[name], track);
                },
                insert : function(obj, exec, keys, end) {
                    var numInserts = obj[name].length;
                    obj[name].forEach(function(child) {
                        bound.insert(child, exec, keys, function() {
                            if (--numInserts === 0 && end !== undefined) end();
                        });
                    });
                }
            }
        },
        joins : "many"
    }
};

exports.enumerate = function(column, condition) {
    return {
        bind : function(key, table, store, name) {
            if (name === undefined) name = key;
            var bound = exports.bind(column, store.many(table, key, condition), store);
            return {
                extract : function(row, result, track) {
                    var field = [];
                    bound.extract(row, field, track);
                    if (field.length === 1) {
                        if (result[name] === undefined) {
                            result[name] = [field[0][column]];
                        } else {
                            result[name].push(field[0][column]);
                        }
                    }
                },
                insert : function(obj, exec, keys, end) {
                    var numInserts = obj[name].length;
                    obj[name].forEach(function(val) {
                        var child = {};
                        child[column] = val;
                        bound.insert(child, exec, keys, function() {
                            if (--numInserts === 0 && end !== undefined) end();
                        });
                    });
                }
            }
        },
        joins : "many"
    }
}

exports.rename = function(columnName, descriptor) {
    return {
        bind : function(key, table, store, name) {
            if (name === undefined) name = key;
            var bound = null;
            var column = null;
            if (descriptor === undefined) {
                column = store.column(table, columnName);
            } else {
                bound = descriptor.bind(columnName, table, store, name);
            }
            return {
                extract : function(row, result, track, isNew) {
                    if (bound !== null) {
                        bound.extract(row, result, track, isNew);
                    } else if (descriptor === undefined) {
                        result[name] = row[column.alias];
                    } // else?
                },
                insert : function(obj, rowOrExec, keys, end) {
                    if (bound !== null) {
                        bound.insert(obj, rowOrExec, keys, end);
                    } else if (descriptor === undefined) {
                        rowOrExec[column.name] = obj[name];
                    }
                },
                fkeys : (bound !== null) ? bound.fkeys : null
            }
        },
        joins : (descriptor !== undefined) && descriptor.joins
    }
};

exports.bloat = function(descriptor) {
    return {
        bind : function(key, table, store, name) {
            if (name === undefined) name = key;
            var bound = exports.bind(descriptor, table, store);
            return {
                extract : function(row, result, track) {
                    if (result[name] === undefined) result[name] = {};
                    if (descriptor.joins) {
                        bound.extract(row, result[name], track);
                    } else {
                        bound.recurse(row, result[name], track, true);
                    }
                },
                insert : function(obj, rowOrExec, keys, end) {
                    if (descriptor.joins) {
                        bound.insert(obj[name], rowOrExec, keys, end);
                    } else {
                        bound.collect(obj[name], rowOrExec);
                    }
                },
                fkeys : bound.fkeys
            }
        },
        joins : descriptor.joins
    };
};

exports.transform = function(extract, insert) {
    return {
        bind : function(key, table, store, name) {
            if (name === undefined) name = key;
            var column = store.column(table, key);
            return {
                extract : function(row, result) {
                    result[name] = extract(row[column.alias]);
                },
                insert : function(obj, row) {
                    row[column.name] = insert(obj[name]);
                }
            }
        }
    }
};

exports.expr = function(expr, insertExprs) {
    return {
        bind : function(key, table, store, name) {
            if (name === undefined) name = key;
            var alias = store.selectExpression(name, expr)
            if (insertExprs !== undefined) {
                insertExprs.forEach(function(key, insert) {
                    store.insertExpression(table, key, insert);
                });
            } else {
                insertExprs = {};
            }
            return {
                extract : function(row, result) {
                    result[name] = row[alias];
                },
                insert : function(obj, row) {
                    // TODO
                }
            }
        }
    }
};