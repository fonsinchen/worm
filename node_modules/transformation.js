"use strict";

var uniquifier = 0;

exports.verbatim = function(descriptor) {
    // nice try, but this is flawed. tableDesc can actually consist of 
    // * schemaName
    // * tableName
    // * condition
    // * alias
    // in almost any combination. So we actually need hashes for table descs.
    // aliases have to be reflected in column descs. So a column desc will
    // probably consist of a tableDesc plus a column name and an optional
    // columnAlias. This means we need hashes for those, too.
    // However, we can just make the tableDesc a reference to tables[tableName]
    return {
        bind : function(structure, key) {
            var columnAlias = key;
            var tableAlias = null;

            var desc = null;
            var descEq = null;
            
            return {
                tables : function(tables, tableName) {
                    tableAlias = tableName;
                    desc = [tableAlias, key];
                    descEq = function(otherDesc) {
                        return otherDesc[0] === tableAlias && otherDesc[1] === key;
                    }
                },
                columns : function(columns) {
                    if (columns[columnAlias] === undefined) {
                        columns[columnAlias] = desc;
                    } else if (!descEq(columns[columnAlias])) {
                        columnAlias = tableAlias + '_' + key;
                        if (columns[columnAlias] === undefined) {
                            columns[columnAlias] = desc;
                        } else {
                            while(columns[columnAlias] !== undefined && !descEq(columns[columnAlias])) {
                                columnAlias += uniquifier++;
                            }
                            columns[columnAlias] = desc;
                        }
                    }
                }
            }
        }
    }
}

exports = function(descriptor) {
    var fields = [];
    var children = {};
    
    // TODO: sane abbrevations
    // - if val is a string, assume it's an SQL expression
    // - if val is an object, but doesn't have typical methods assume descriptor for either worm.one or worm.many
    //   * if key contains at least one dot, assume worm.many with qualified fkey name
    //   * if key doesn't contain a dot, assume worm.one with bare fkey name
    descriptor.forEach(function(key, val) {
        if (val === 1) {
            fields.push(key);
        } else {
            children[key] = val;
        }
    });
    
    
    // TODO:
    // first resolve table names and aliases with from(). Keep the mapping
    // around somewhere. Use closures or instances in order to be able to use
    // the same descriptor/transformation multiple times in pseudo-parallel.
    // Then resolve the column names and aliases with select() using the table
    // aliases. Keep the column mappings around, too. Finally, when doing
    // extract() the mappings tell us which columns belong to which properties
    // of the result rows.
    return {
        from : function(result, params) {
            // alias : {schema : "schema", table : "table", condition : "z.fkey = table.key", aliased : false}
            // Create normalized conditions to be able to string-compare them
            // and avoid multiple equivalent joins.
            return cascade(result, 'from', params);
        },
        select : function(result, params) {
            // Qualified column names are not enough! The database may return 
            // unqualified column names. The best bet is probably to keep all
            // column names in a mapping and alias them as their qualified names
            // with SQL 'AS' when necessary:
            // {
            //  'x' : {schame : 'schema', table : 'table', column : 'x'},
            //  'table2.x' : {schema : 'schema', schema : 'table2', column : 'x'}, 
            //  'schema2.table2.x' : {alias : 'tableAlias', column : 'x'}
            // }
            // The mapping has to be around when extracting later.
            var qui = params.driver.quoteUnqualifiedIdentifier;
            var tablePrefix = (params.schema === null ? '' : qui(params.schema) + '.') +
                    qui(params.table) + '.';
            var select = fields.map(function(field) {
                return tablePrefix + qui(field);
            });
            return cascade(select, 'select', params);
        }
    }   
};