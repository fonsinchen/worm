"use strict";

var sqlexpr = require('sqlexpr');

exports = function(descriptor) {
    var fields = [];
    var children = {};
    
    // TODO: sane abbrevations
    // - if val is a string, assume it's an SQL expression
    // - if val is an object, but doesn't have typical methods assume descriptor for either worm.one or worm.many
    //   * if key contains at least one dot, assume worm.many with qualified fkey name
    //   * if key doesn't contain a dot, assume worm.one with bare fkey name
    descriptor.forEach(function(key, val) {
        if (val === 1) {
            fields.push(key);
        } else {
            children[key] = val;
        }
    });
    
    
    // TODO:
    // first resolve table names and aliases with from(). Keep the mapping
    // around somewhere. Use closures or instances in order to be able to use
    // the same descriptor/transformation multiple times in pseudo-parallel.
    // Then resolve the column names and aliases with select() using the table
    // aliases. Keep the column mappings around, too. Finally, when doing
    // extract() the mappings tell us which columns belong to which properties
    // of the result rows.
    return {
        from : function(result, params) {
            // alias : {schema : "schema", table : "table", condition : "z.fkey = table.key", aliased : false}
            // Create normalized conditions to be able to string-compare them
            // and avoid multiple equivalent joins.
            return cascade(result, 'from', params);
        },
        select : function(result, params) {
            // Qualified column names are not enough! The database may return 
            // unqualified column names. The best bet is probably to keep all
            // column names in a mapping and alias them as their qualified names
            // with SQL 'AS' when necessary:
            // {
            //  'x' : {schame : 'schema', table : 'table', column : 'x'},
            //  'table2.x' : {schema : 'schema', schema : 'table2', column : 'x'}, 
            //  'schema2.table2.x' : {alias : 'tableAlias', column : 'x'}
            // }
            // The mapping has to be around when extracting later.
            var qui = params.driver.quoteUnqualifiedIdentifier;
            var tablePrefix = (params.schema === null ? '' : qui(params.schema) + '.') +
                    qui(params.table) + '.';
            var select = fields.map(function(field) {
                return tablePrefix + qui(field);
            });
            return cascade(select, 'select', params);
        }
    }   
};

exports.prepare = function(descriptor) {
    descriptor.forEach(function(key, child) {
        switch(typeof child) {
            case 'string':
                descriptor[key] = exports.expr(child);
                break;
            case 'number':
                descriptor[key] = exports.verbatim(child);
                break;
        }
    });
}

var uniquifier = 0;

exports.varbatim = function() {
    return {
        bind : function(structure, key) {
            var columnAlias = key;
            var desc = null;
            
            return {
                joinTables : function(tables, info) {
                    desc = [info.tableAlias(), key];
                },
                aliasedColumns : function(columns) {
                    while(columns[columnAlias] !== undefined &&
                            (columns[columnAlias][0] !== desc[0] ||
                            columns[columnAlias][1] !== desc[1])) {
                        columnAlias += uniquifier++;
                    }
                    columns[columnAlias] = desc;
                }
            }
        }
    }
};

exports.expr = function(expr, insertExprs) {
    var parseTree = sqlexpr.parse(expr);
    var parsedInserts = {};
    if (insertExprs !== undefined) {
        insertExprs.forEach(function(key, insert) {
            parsedInserts[key] = sqlexpr.parse(insert);
        });
    }
    return {
        bind : function(structure, key) {
            var columnAlias = key;
            return {
                // TODO: here we have different columns depending on mode
                // for now we only consider SELECT
                aliasedColumns : function(columns) {
                    while(columns[columnAlias] !== undefined) {
                        columnAlias += uniquifier++;
                    }
                    columns[columnAlias] = parseTree;
                }
            }
        }
    }
};

var join = function(descriptor, condition, bindKey) {
    prepare(descriptor);
    return {
        bind : function(structure, keyName, info) {
            var key = info.table()[bindKey][keyName];
            var tableDesc = {
                schema : key.schema,
                table : key.table,
                condition : condition
            };
            var child = require('bind').sub(descriptor, structure, tableDesc, keyName);
            return {
                joinTables : function(tables, info) {
                    var subInfo = child.tables(tables, info);
                    var fkey = (bindKey === 'lkey' ? subInfo.table().fkeys[key.name] : key);
                    if (tableDesc.condition === undefined) {
                        var condition = [];
                        fkey.columns.forEach(function(column, i) {
                            if (condition.length > 0) condition.push('AND');
                            condition.push({
                                table : info.tableAlias(),
                                column : column
                            }, '=', {
                                table : subInfo.tableAlias(),
                                colun : fkey.foreign_columns[i]
                            });
                        });
                    }
                },
                aliasedColumns : child.columns
            }
        }
    }
}

exports.many = function(descriptor, condition) {
    return join(descriptor, condition, 'lkey');
};

exports.one = function(descriptor, condition) {
    return join(descriptor, condition, 'fkey');
};