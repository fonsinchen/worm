"use strict";

exports = function(descriptor) {
    var fields = [];
    var children = {};
    
    // TODO: sane abbrevations
    // - if val is a string, assume it's an SQL expression
    // - if val is an object, but doesn't have typical methods assume descriptor for either worm.one or worm.many
    //   * if key contains at least one dot, assume worm.many with qualified fkey name
    //   * if key doesn't contain a dot, assume worm.one with bare fkey name
    descriptor.forEach(function(key, val) {
        if (val === 1) {
            fields.push(key);
        } else {
            children[key] = val;
        }
    });
    
    
    // TODO:
    // first resolve table names and aliases with from(). Keep the mapping
    // around somewhere. Use closures or instances in order to be able to use
    // the same descriptor/transformation multiple times in pseudo-parallel.
    // Then resolve the column names and aliases with select() using the table
    // aliases. Keep the column mappings around, too. Finally, when doing
    // extract() the mappings tell us which columns belong to which properties
    // of the result rows.
    return {
        from : function(result, params) {
            // alias : {schema : "schema", table : "table", condition : "z.fkey = table.key", aliased : false}
            // Create normalized conditions to be able to string-compare them
            // and avoid multiple equivalent joins.
            return cascade(result, 'from', params);
        },
        select : function(result, params) {
            // Qualified column names are not enough! The database may return 
            // unqualified column names. The best bet is probably to keep all
            // column names in a mapping and alias them as their qualified names
            // with SQL 'AS' when necessary:
            // {
            //  'x' : {schame : 'schema', table : 'table', column : 'x'},
            //  'table2.x' : {schema : 'schema', schema : 'table2', column : 'x'}, 
            //  'schema2.table2.x' : {alias : 'tableAlias', column : 'x'}
            // }
            // The mapping has to be around when extracting later.
            var qui = params.driver.quoteUnqualifiedIdentifier;
            var tablePrefix = (params.schema === null ? '' : qui(params.schema) + '.') +
                    qui(params.table) + '.';
            var select = fields.map(function(field) {
                return tablePrefix + qui(field);
            });
            return cascade(select, 'select', params);
        }
    }   
};

var uniquifier = 0;

exports.varbatim = function() {
    return {
        bind : function(structure, key) {
            var columnAlias = key;
            var desc = null;
            
            return {
                tables : function(tables, info) {
                    desc = [info.tableAlias(), key];
                },
                columns : function(columns) {
                    while(columns[columnAlias] !== undefined &&
                            (columns[columnAlias][0] !== desc[0] ||
                            columns[columnAlias][1] !== desc[1])) {
                        columnAlias += uniquifier++;
                    }
                    columns[columnAlias] = desc;
                }
            }
        }
    }
};

exports.expr = function(expr, insertExprs) {
    return {
        bind : function(structure, key) {
            var columnAlias = key;
            return {
                columns : function(columns) {
                    while(columns[columnAlias] !== undefined && columns[columnAlias] !== expr) {
                        columnAlias += uniquifier++;
                    }
                    columns[columnAlias] = expr;
                }
            }
        }
    }
};

var join = function(descriptor, condition, bindKey) {
    return {
        bind : function(structure, keyName, info) {
            var key = info.table()[bindKey][keyName];
            var tableDesc = {
                schema : key.schema,
                table : key.table,
                condition : condition
            };
            var child = require('bind').sub(descriptor, structure, tableDesc, keyName);
            return {
                tables : function(tables, info) {
                    var subInfo = child.tables(tables, info);
                    var fkey = (bindKey === 'lkey' ? subInfo.table().fkeys[key.name] : key);
                    if (tableDesc.condition === undefined) {
                        var condition = [];
                        fkey.columns.forEach(function(column, i) {
                            // TODO: it's probably silly to generate a condition
                            // string here and later parse it to generate driver
                            // specific SQL. Better specify the parse tree here.
                            condition.push('"' + info.tableAlias() + '"."' + column +
                                '"="' + subInfo.tableAlias() + '"."' + fkey.foreign_columns[i] + '"');
                        });
                        tableDesc.condition = condition.join(' AND ');
                    }
                },
                columns : child.columns
            }
        }
    }
}

exports.many = function(descriptor, condition) {
    return join(descriptor, condition, 'lkey');
};

exports.one = function(descriptor, condition) {
    return join(descriptor, condition, 'fkey');
};